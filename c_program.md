| 水仙花数                           | 三位正整数各位数字的立方和为该正整数                       |
| ---------------------------------- | :--------------------------------------------------------- |
| **四舍五入(强制转化不能四舍五入)** | **(int)(value * 10 + 5) / 10**                             |
| **最小公倍数**                     | **（最大值之后一直相乘自加值后除另一个值模为零）**         |
| **最大公约数**                     | **大值小值取模，小值与模值取模，直到模为零，被模值为所求** |
| **冒泡排序法**(相邻交换,多次交换)  | 两次循环，每次循环选最值，继续大循环，再选出最值第二，依次 |
| **选择排序法**(一次循环,一次交换)  | 两次循环，内循环依次找出最值的位置与首位或末位交换         |
| **杨辉三角型**                     | 每个位置的值都是上一行同列与上一列位置上的值的和           |
|                                    |                                                            |
|                                    |                                                            |
|                                    |                                                            |

[TOC]



# 程序分析题

* **注意循环体的包含内容，划出来**
* **程序内容输出要正确分析完毕**

# 转义字符

\n	\t	\b	\r	\f	\ \	\ '	\ "	\a	\ddd(1~3为八进制)	\xhh(1~2为十六进制)

# 变量

存在多个同变量名的变量，以函数体内部的为主，没有在内部的话，就优先全局变量

| **extern变量**   | **全局变量在该作用于之外的使用**                             |
| ---------------- | ------------------------------------------------------------ |
| **register变量** | **寄存器变量【局部自动变量和形参可以作为register】（可以提高程序的运行速度）** |
| **static变量**   | **静态变量，只运行一次，不论在什么地方**                     |
| **auto变量**     | **动态分布存储空间，默认为auto变量**                         |
| **全局变量**     | **作用域：从全局变量定义开始，到该文本文件结束都可以使用**   |

int长度是计算机的字长；16位计算机：2bytes；32位计算机：4bytes

double为64位，8bytes

float为32位，4bytes

char为8位，1byte

long为 *2

short为 /2

# 运算

***float变量初始化要加   f，0.0；***

*P &a **只要是紧挨着就视作整体**

算术运算

移位运算

关系运算

逻辑运算

逗号运算与？：运算

# 输入输出

**“format”相当于字符串指针**

## printf()格式

| %d或%i | 整型             |
| ------ | ---------------- |
| %c     | 字符型           |
| %u     | 无符号数整型     |
| %o     | 八进制           |
| %x     | 十六进制         |
| %ld    | 长整型           |
| %s     | 字符串型         |
| %e     | 浮点型的指数输出 |
| %f     | 浮点型           |
| -      | 靠左对齐         |
| +			 |输出符号，（正号）|
| #			 |加上进制输出标志|

输出最小宽度，包含E . 等

精度包含E



## scanf()格式

# 数组

## 一维数组

### 定义

数组类型 数组名 [ 常量表达式 ]
$$
常量表达式 = 常量数值 + 符号常量
$$


### 初始化

* 全部写出来
* 省略常量表达式，但所有数字不省略
* 所有数字相同，可以只写一个，但常量表达式不省略
* 数组默认初始值：

| 整型数组       | 0        |
| -------------- | -------- |
| **字符型数组** | **’\0‘** |
| **指针型数组** | **NULL** |

### 引用

数组名 [ 变量表达式 ]

## 二维数组

### 定义

同上

### 初始化

* 全部写出来
* 省略行的常量表达式，但是行数要全部表示出来
* 数据可以全部罗列，也可以按照每行{}包含罗列，{}内数据规律也可以省略或者全不相同
* 全部数据相同，可以只写一个
* 数组默认初始值

### 存储方式

二维数组元素在内存中的存放顺序是**按行主顺序存放**

## 字符型数组

### 表现方式

#### 字符表示

用单引号让每一个字符包含

#### 字符串表示

用双引号将字符串包含

> **注意**：在字符串表示的时候，字符数组最后一个字符为'\0'，而字符表示并没有这种情况。

### 输出方式

循环输出，而且每次输出字符时，遇到'\0'就结束。

### 常用的字符串库函数

#### strlen(char *a1)

获取字符串有效长度，长度作为返回值

#### strcmp(char *a1,char *a2)

比较字符串 ，a1 - a2作为返回结果

strnncmp(char *a1,char *a2，int n)

比较a1和a2的前n个字符

#### strcpy(char *a1,char *a2)

a2复制到a1，a1数组作为返回值

strncpy(char *a1,char *a2，int n)

复制a2的前n个字符

#### strcat(char *a1,char *a2)

a1后接上a2，作为a1，a1作为返回值

strncat(char *a1,char *a2，int n)

接上a2的前n个字符

# 函数

* 一个函数一般由两个部分组成，它们是函数说明部分和函数体
* ==函数定义和调用在同一个文件中，在调用之前要声明或者定义要在调用之前==

## 函数的定义

函数类型 函数名（函数参数）

## 函数的调用

* 函数语句调用
* 函数表达式调用
* 函数参数调用
* 函数调用嵌套

> C语言中不允许函数的嵌套定义，但可以在函数定义中调用其他函数

* 函数递归调用

> C语言中允许在函数定义中调用自身函数

* 外部函数extern方法声明后方可在声明的源文件中调用
* 内部函数static之后只能在该文件中使用

## 参数

### 参数的传递

#### 值传递方式

内部产生的值只能由return传递出来

#### 地址传递方式

内部造成外部变量值的变化

### 形参与实参

* 形参与实参存放的地址不相同（除了地址传递方式）
* 形参只有在调用的时候会被分配空间，调用完毕，分配的空间就会被释放
* 实参与形参类型不同，则强制转化为形参类型

### 数组作为形参

#### 数组名可以作为形参

一维数组可以省略数组元素个数

二维数组只能省略数组的行数

#### 指针作为形参

### 数组作为实参

#### 数组某元素作为实参数据

#### 整个数组作为实参

数组作为实参只能传递数组地址，即数组名

## 返回值

* 返回值与函数类型相一致，不一致以函数类型为主，默认类型为int型，可以省略

* 需要返回值，但没有return，就会随即返回

* void 无返回值

# 编译预处理

* 预处理是指在进行编译的第一遍扫描之前所的工作，他由预处理程序负责完成。

* 预处理命令行都是以#开始的
* 宏替换不占用运行时间，只占用编译时间

## 宏定义

* 宏定义分为带参数的宏定义和不带参数的宏定义两种

### 不带参的宏定义

* 宏定义的格式为  ==宏名只代替字符串==

> #define 宏名 字符串【字符串中可以包含任何字符，可以常数，也可以是表达式】

* 宏定义必须写在函数之外，宏定义失效可以使用#undef
* 若宏名在函数中用 “ ” 包含，则不能宏替换

### 带参的宏定义

* #define 宏名(参数)   字符串

> 使用时，宏名(参数)

* 括号的作用

## 文件包含

* #include

> " "和<>的区别当前所在目录查找之后再按照标准形式查找；直接按照标准形式查找

## 条件编译

和普通的if else if   endif 类似

```c
#if 常数表达式 
		语句段1
#elif 表达式
    语句段2
#else
		语句段3
#endlif
```

```c
#ifdef 宏名 //如果定义了，就运行
		语句段1
#ifndef 宏名 //如果没被定义，就运行
    语句段2
#endif
```

# 指针

* 未经赋值的指针变量不能使用,必须指定指向

* 指针不能空赋值即`int *p,*q; p=q;//错误的`
* `int *p,m;中p=&m和*p=m的区别`
* 指针使用内容时，必须明确其地址；
* 指针字符串赋值只用“	==指针 = “    ”==	 “

## 指针的自加自减

指针自加自减取决于是整型指针，字符指针还是浮点型指针；

自加自减表示加上或减去类型所占的字节数

## 指针与字符串

* `char *p = "字符串"`
* `char *p; p="字符串"`

## 指针与数组

数组长度和指针的字符串长度**不相同**，**\0的区别**

数组名不能相当于指针进行字符串赋值，它仅仅代表数组首地址，不能进行其它改变

### 一维数组【`int a[10],*p;`】

* 数组名表示数组的首地址
* 数组名+a，表示"数组名[a]"的地址
* `p=a`	**`p=a+1 //等价于p的地址+4`**	`(*p)[i]表示数组a[i]`	
* 数组名不能自加

### 多维数组【`int a[10][10],*p;`】

* 同上

* `p = a[i]`    `p = &a[i][j]`    **`*a  *(a+i) *(*(a+i)+j)`**    `int *a[]//不限行，列不唯一`

# 自定义==数据类型==

## 结构体 

结构体变量，系统分配给它的内存为各成员所需内存量的总和

### 结构体定义

```c
struct student
{
  int num;
  char *name;
  int age;
  char *sex; 
  struct 
  {
    int year;
    int day;
    int month;
  }birth;	//该birth为该无名结构体的结构体变量
};		//该分号不能缺
```

### 结构体变量的定义

#### 结构体与变量定义分开

````
struct student stu1;
struct student stu2;
//stu1,stu2都是结构体变量名
````

#### 结构体与变量结合

```c
struct student
{int num;
  char *name;
  int age;
  char *sex; 
  struct 
  {
    int year;
    int day;
    int month;
  }birth;	//该birth为该无名结构体的结构体变量 
}stu1,stu2;  //定义stu1 stu2的名为student的结构体的结构体变量
```

#### 无结构体名的定义

```c
struct
{
  int num;
  char *name;
  int age;
  char *sex; 
  struct 
  {
    int year;
    int day;
    int month;
  }birth;	//该birth为该无名结构体的结构体变量 
}stu1,stu2;  //定义stu1 stu2的结构体变量，该结构体没有结构体名
```

### 结构体变量的引用

```c
stu1.num = 10;
stu1.num++;//表示在stu1中的num实现自加；而不是结构体中num自加
stu2.name = "lishuyang";
stu1.birth.year = 1999;
stu2.birth.month = 9;
```

### 结构体变量的初始化

可以如引用一样一一赋值；

```c
struct
{
  int num;
  char *name;
  int age;
  char *sex; 
  struct 
  {
    int year;
    int day;
    int month;
  }birth;	//该birth为该无名结构体的结构体变量 
}stu1 = {10,"lishuyang",20,"male",{1999,2,9}};
```

### 结构体数组

其实就是将上面的结构体变量换成了结构体数组

相当于多个结构体变量的集合组成了数组；相当于一个二维数组

```c
struct
{
  int num;
  char *name;
  int age;
  char *sex; 
  struct 
  {
    int year;
    int day;
    int month;
  }birth;	//该birth为该无名结构体的结构体变量 
}stu[2] = {{10,"lishuyang",20,"male",{1999,2,9}},
  {11,"lienze",20,"female",{1999,27,9}}};
//该变量为结构体变量
```

### 结构体指针

```c
struct student *stu1;
stu1->num = 10;//stu1->age 已经不是指针了，就是一个整型数据，将其视为一个整体，不能分开看
stu1->name = "lishuyang";
(*stu1).age = 20;
```

### 指向结构体数组的指针

```c
struct student stu[10];
struct student stu_p = stu;
```

## 结构体作为函数参数

结构体变量作为形参

结构体变量指针作为形参

结构体内部成员作为形参

## 共用体（内存为成员中占内存量最大者所需的容量）

共用体的定义，初始化与结构体类似

union代替struct

之所以叫做共用体，是因为所有成员共用一个存储空间；

初始化只能为第一个成员初始化；赋值的话只能对成员赋值，赋值按最新的赋值存入地址；

## 枚举类型

enum内部的成员默认依次为0，1，2...【除非已经定义好初始成员的值，之后成员自加1】

而且枚举类型的变量不能直接赋值为数值，而赋值为数值代替的成员，

如果一定是数值的话要加上“（枚举类型名）”

## typedef

```c
typedef int Integer; //指定 Integer 为类型名，代表int
//命名新的结构体类型、枚举类型、共用体类型、指针类型、数组类型
//typedef 相当于 #define 的功能，区别就是代替的一个是字符串，一个是各种数据类型
```



# 文件

从用户角度看，文件可分为普通文件和设备文件

从文件编码方式上来看，文件可分为ASCII码文件和二进制码文件

C语言中，文件的存取是以字符为单位的，这种文件被叫做流式文件

C语言中，文件可以用顺序方式存取，也可以用随机方式存取

文件指针FILE

```c
FILE *fp;//文件操作的初始化
```

 文件的打开与关闭

```c
fp = fopen(文件名,打开方式); //失败返回NULL，成功fp指针
/*  "rt"		打开文本文件，只读
		"wt"		打开或新建文本文件，只写
		"at"		打开文本文件，末尾写
		"rb"		打开二进制文件，只读
		"wb"		打开或新建二进制文件，只写
		"ab"		打开二进制文件，末尾写
		"rt+"		打开文本文件，读写
		"wt+"		打开或新建文本文件，读写
		"at+"		打开文本文件，读或末尾写
		"rb+"		打开二进制文件，读写
		"wb+"		打开或新建二进制文件，读写
		"ab+"		打开二进制文件，读或末尾写*/
fclose(fp);//返回0或EOF(end of file)
```

文件的读取与写入

```c
	fgetc(fp);//读取一个字符
/*	错误：EOF
		正确：返回得到的字符*/




	fputc('字符',fp);//将字符写入
/*	错误：EOF
		正确：返回写入的字符*/




	fputs("字符串",fp);//将字符串写入
/*	错误：EOF
		正确：返回非负值*/


	fgets(字符数组名,length,fp);//将（length-1）字节的字符串赋值到字符数组中,最后为"\0"
/*	在读取最后一个字符前就遇到了'\n'或文件的末尾EOF，只会返回读取到的字符，包括换行符*/


	fprintf(fp,"%d",n);//将n的值打印到文件中
/**/


	fscanf(fp,”%d“,&n);//将文件内容读取n中
/*遇到空格就结束*/



	fread(指针,size,count,fp);//将文件中的内容读取count次，每次读取size字节
	fwirte(指针,size,count,fp);//将指针中的内容分count次写入，每次写入size字节
```

​	

​	文件位置指针的移动

```c
	fseek(fp,位移量,起始点);//一般用于二进制文件
/*	起始点:	SEEK_SET 0 文件开头
						SEEK_CUR 1 当前位置
						SEEK_END 2 文件末尾*/
/*	位移量为long型，故数据后常常加上L
		负值：向前
		正值：向后*/

	rewind(fp);//移动文件位置指针重新移动到文件开头
	
	ftell(fp);//得到当前文件位置指针距离开头的字节数
```

判断位置指针是否在文件结束符处，即是否在文件末尾处

```c
feof(fp);
/*	yes:非零值
		no :0*/
```

​	


​	