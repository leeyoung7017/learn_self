# 称重机代码笔记

* 只用到了一个串口，usart1——进行串口接收中断
* 外部中断，当触发下降沿时，就会触发外部中断 
  * 外部中断中 9_5通道会实现==数据接收==、

## tim2定时中断

动作指令基本上全部在定时器中动作

* 500\*0.5ms中实现	如果是静态下，则进行数据的获取，即为静态获取值，并传输给串口屏
* flag_screen标志下   实现动态获取数据并传输给串口屏
* 通过标志位控制来回拨动
* 读取串口屏指令    ==什么时候开始获取的    每500*0.5ms进行读取？？？？==

flag_test		 	串口屏指令获取标志位

flag_screen		动态获取标志位

average_flag	

over_top			  区间1标志位

below_bottom	区间3标志位

timer.c ——valve			回拨时间

timer.c ——valve_keep	保持时间+回拨时间=总时间				动作完成将标志位清零

## 外部中断

> AD7191芯片中DOUT/RDY引脚中数据准备好后该引脚触发下降沿，==下降沿触发外部中断==

外部中断处理函数主要实现各种指令的中断标志的控制操作

* 动态数据获取与处理，控制上下波动标志位的控制
* 静态下数据获取，







## 串口屏与下位机

```C
/*重量数据传输到串口屏*/	/*ad7191.c*/
void data_and_send(void);

/*串口屏数据读取*/    /*usart1.h*/
void READ_HMI(u16 address,u8 lenth);

/**/
#define ADDR 0x1111	/*串口屏重量显示*/
```



# 代码修改部分

* 上下限与修正系数在timer.c中只读取一次；\~~~253
* 添加了读取载入产品地址的数据，从而获取上下限、修正系数与品名的地址;      timer.c~~253
* 上下限、修正系数、品名可以动态读取并上传指定地址在usart_op.c中
* 修改了部分command_x的指令地址内容     usart_op.c\~151
* 在获取到上下限的反馈数据将数据上传会指定地址         usart_op.c\~259\~268
* 添加了WRITE_HMI函数供单片机写入串口屏，采用了与上传0x1111一致的代码\~~~usart1.c

